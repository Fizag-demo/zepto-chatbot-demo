import json
import re
from rapidfuzz import process, fuzz
from datetime import datetime, date
import os
from huggingface_hub import InferenceClient
from dotenv import load_dotenv
from prompts import (
    SYSTEM_PROMPT,
    INSTRUCTION_PROMPT,
    EXAMPLE_PROMPT,
    REFUND_PROMPT,
    MULTIITEM_PROMPT,
)

# ------------------ FILE PATHS ------------------
CHAT_FILE = "chat_data.json"
ZEPTO_FILE = "zepto_data.json"
UNANSWERED_FILE = "unanswered.json"

# ------------------ LOAD JSON DATA ------------------
with open(CHAT_FILE, "r", encoding="utf-8") as f:
    faq_data = json.load(f)

with open(ZEPTO_FILE, "r", encoding="utf-8") as f:
    zepto_data = json.load(f)

if not os.path.exists(UNANSWERED_FILE):
    with open(UNANSWERED_FILE, "w", encoding="utf-8") as f:
        json.dump([], f)

# ------------------ LOAD API KEY ------------------
load_dotenv()
HUGGINGFACE_API_KEY = os.getenv("HUGGINGFACE_API_KEY")

# âœ… Model: 8B for balanced speed + reasoning
client = InferenceClient(
    model="meta-llama/Meta-Llama-3-8B-Instruct",
    token=HUGGINGFACE_API_KEY
)

# ------------------ CONTEXT MEMORY ------------------
context_memory = {
    "last_item": None,
    "last_category": None,
    "last_intent": None,
    "history": []
}

# ------------------ CATEGORY HINTS ------------------
CATEGORY_HINTS = {
    "Fruits & Vegetables": ["onion", "tomato", "banana", "apple", "mango", "beans", "carrot", "mint", "coriander"],
    "Dairy, Bread & Eggs": ["milk", "butter", "bread", "egg", "cheese", "paneer", "curd"],
    "Atta, Rice, Oil & Dals": ["rice", "wheat", "atta", "oil", "dal", "flour", "maida", "besan", "sugar"],
    "Masala & Dry Fruits": ["spices", "masala", "almonds", "cashew", "raisins"],
    "Biscuits & Cookies": ["biscuits", "cookies", "oreo", "crackers"],
    "Tea, Coffee & More": ["tea", "coffee", "green tea"],
    "Frozen Food": ["ice cream", "frozen paratha", "frozen peas"],
    "Bath & Body": ["soap", "face wash", "cream"],
    "Hair Care": ["shampoo", "conditioner", "hair oil"],
}

# ------------------ HELPERS ------------------
def clean_text(text):
    return re.sub(r"[^\w\s&,]", "", text.lower().strip())

def append_to_history(role, content):
    context_memory["history"].append({"role": role, "content": content})
    if len(context_memory["history"]) > 8:
        context_memory["history"].pop(0)

def save_unanswered(question):
    try:
        with open(UNANSWERED_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        data = []
    data.append({"question": question, "timestamp": datetime.now().isoformat()})
    with open(UNANSWERED_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

def update_context(item=None, category=None, intent=None):
    if item:
        context_memory["last_item"] = item
    if category:
        context_memory["last_category"] = category
    if intent:
        context_memory["last_intent"] = intent

# ------------------ FAQ ------------------
def check_faq(user_input):
    blocked_terms = ["type", "types", "brand", "variety", "rice", "dal", "oil", "sugar", "flour", "how", "what", "why", "order"]
    if any(term in user_input for term in blocked_terms):
        return None

    questions = list(faq_data.keys())
    best = process.extractOne(user_input, questions, scorer=fuzz.token_set_ratio)
    if not best:
        return None
    best_match, score, _ = best
    return faq_data[best_match] if score > 75 else None

# ------------------ QUANTITY & NORMALIZE ------------------
def extract_quantity(user_input):
    match = re.search(r"(\d+(?:\.\d+)?)\s*(kg|kgs|g|grams|packet|packets|piece|pieces|unit|units|dozen|ltr|litre|litres|l)?", user_input)
    if not match:
        return (None, None)
    qty = float(match.group(1))
    unit = (match.group(2) or "").strip()
    return (qty, unit)

def normalize_word(word):
    if word.endswith("ies"): return word[:-3] + "y"
    if word.endswith("es") and word[:-2] not in ["cheese", "dress"]: return word[:-2]
    if word.endswith("s") and word not in ["gas", "glass", "class"]: return word[:-1]
    return word

# ------------------ REFUND HANDLER ------------------
def handle_refund_queries(user_input):
    text = user_input.lower()

    if "not received" in text or "still waiting" in text or "haven't" in text:
        return (
            "Sorry about the delay ğŸ™. Once your returned item is verified, "
            "Zepto usually processes refunds within **7 business days**. "
            "If it's been longer, check your Zepto app order history or contact support."
        )

    if "cod" in text or "cash on delivery" in text:
        return (
            "For **COD orders**, refunds are usually given as **Zepto Cash** or vouchers â€” "
            "usable for future orders."
        )

    if any(k in text for k in ["upi", "card", "netbanking", "prepaid"]):
        return (
            "For **prepaid** orders, refunds go to your original payment method within **7 working days** "
            "after return verification."
        )

    if "policy" in text or "return" in text or "exchange" in text:
        return (
            "ğŸ›ï¸ **Zepto Return Policy (summary):**\n"
            "- Most items are returnable except perishables or hygiene products.\n"
            "- Raise a request within 24 hours via **My Orders â†’ Help â†’ Return/Replace.**\n"
            "- Refunds processed in 3â€“7 days after verification."
        )

    return (
        "Refunds are processed within **7 business days** after the item is verified. "
        "COD refunds â†’ Zepto Cash, Prepaid â†’ original bank/card."
    )

# ------------------ ITEM CHECK ------------------
def check_items(user_input):
    user_input = clean_text(user_input)
    responses, matched = [], False

    # Reject flowers / plants
    if any(x in user_input for x in ["lotus", "plant", "tree", "flower"]):
        return "ğŸŒ¸ Zepto offers basic bouquets only â€” not full flower or plant categories yet."

    # Restricted categories
    restricted = {
        "appliances": ["fridge", "tv", "microwave", "ac", "washing machine"],
        "footwear": ["shoe", "sandals", "slippers"],
        "fashion": ["tshirt", "jeans", "dress", "jacket", "clothes"],
    }
    for cat, keys in restricted.items():
        if any(k in user_input for k in keys):
            return f"âŒ Zepto doesnâ€™t sell {cat} yet â€” only groceries and daily essentials."

    # Hint category
    for category, words in CATEGORY_HINTS.items():
        if any(k in user_input for k in words):
            update_context(category=category)
            break

    # Multi-item split
    parts = re.split(r"\s+(?:and|&)\s+|,", user_input)
    for part in [p.strip() for p in parts if p.strip()]:
        qty, unit = extract_quantity(part)
        for category, items in zepto_data.get("items", {}).items():
            for item, price in items.items():
                if fuzz.partial_ratio(normalize_word(item), part) > 85:
                    matched = True
                    update_context(item, category, "product_query")
                    if qty:
                        total = qty * price
                        responses.append(f"âœ… {item.title()} â€” {qty} {unit or 'unit'} costs â‚¹{int(total)} (â‚¹{price}/unit).")
                    else:
                        responses.append(f"âœ… {item.title()} is available under {category.title()} for â‚¹{price}.")
        # continue to next part for multi-item support

    if matched:
        return "\n".join(responses)

    # Grocery AI fallback
    grocery_terms = ["rice", "dal", "oil", "atta", "flour", "ghee", "butter", "tomato", "onion", "sugar"]
    if any(t in user_input for t in grocery_terms):
        return ask_ai_fallback(
            f"User asked: '{user_input}'. Reply as Zepto grocery assistant with Yes/No + prices."
        )

    return ask_ai_fallback(
        f"User asked: '{user_input}'. Respond politely as Zepto assistant with relevant info and â‚¹ prices."
    )

# ------------------ AI FALLBACK ------------------
def ask_ai_fallback(user_input):
    last_item = context_memory.get("last_item")
    last_category = context_memory.get("last_category")

    context_prompt = f"""
Recent Context:
- Last item: {last_item or 'None'}
- Last category: {last_category or 'None'}
User query: "{user_input}"
"""

    base_prompt = (
        f"{SYSTEM_PROMPT}\n{INSTRUCTION_PROMPT}\n{EXAMPLE_PROMPT}\n{REFUND_PROMPT}\n{MULTIITEM_PROMPT}\n{context_prompt}"
        "\nIf it's a grocery/daily item, always answer 'Yes' with a realistic â‚¹ price. "
        "If not sold, politely say so. Sound like a friendly Zepto WhatsApp assistant."
    )

    messages = [{"role": "system", "content": base_prompt}]
    messages.extend(context_memory["history"])
    messages.append({"role": "user", "content": user_input})

    try:
        response = client.chat.completions.create(
            model="meta-llama/Meta-Llama-3-8B-Instruct",
            messages=messages,
            max_tokens=350,
            temperature=0.6,
        )
        content = response.choices[0].message["content"].strip()
        content = re.sub(r"(\$|USD|usd|dollars?)", "â‚¹", content)
        append_to_history("assistant", content)
        return content
    except Exception as e:
        print("âš ï¸ AI fallback error:", e)
        return "I'm having trouble reaching the AI service right now â€” but I can help with refund or product details."

# ------------------ MAIN RESPONSE ------------------
def chatbot_response(user_input):
    append_to_history("user", user_input)
    user_input_clean = clean_text(user_input)

    # ğŸ‘‹ Greeting
    if any(word in user_input_clean.split() for word in ["hi", "hello", "hey", "hii", "hola"]):
        reply = "Hi ğŸ‘‹! Welcome to Zepto â€” how can I help you today?"
        append_to_history("assistant", reply)
        return reply

    # ğŸ’¸ Refund Queries
    if any(w in user_input_clean for w in ["refund", "money back", "reimburse", "not received"]):
        update_context(intent="refund")
        return handle_refund_queries(user_input)

    # ğŸ” Return / Replace Queries
    if any(w in user_input_clean for w in ["return", "replace", "exchange", "wrong item", "damaged", "expired"]):
        update_context(intent="return")
        return (
            "ğŸ” To return or replace an item, open the **Zepto app â†’ My Orders â†’ Help â†’ Return/Replace.**\n"
            "Attach a photo of the item if damaged/wrong. Once verified, a refund or replacement will be processed within 3â€“7 business days."
        )

    # âŒ Cancel Order Queries
    if any(w in user_input_clean for w in ["cancel", "cancellation", "stop order", "cancel order"]):
        update_context(intent="cancel")

        if "one item" in user_input_clean or "single item" in user_input_clean:
            return (
                "ğŸ›’ You can cancel an **individual item** only if it hasnâ€™t been packed yet.\n"
                "Go to **My Orders â†’ Select Order â†’ tap on the item â†’ Cancel Item.**\n"
                "If already packed or shipped, cancellation may not be possible."
            )

        return (
            "âŒ You can cancel your order directly from the **Zepto app** before it's dispatched.\n"
            "Go to **My Orders â†’ Select Order â†’ Cancel Order.**\n"
            "If itâ€™s already out for delivery, please refuse to accept it on arrival."
        )

    # â“ FAQ
    faq_ans = check_faq(user_input_clean)
    if faq_ans:
        append_to_history("assistant", faq_ans)
        return faq_ans

    # ğŸ›ï¸ Product / Quantity
    item_ans = check_items(user_input_clean)
    if item_ans:
        append_to_history("assistant", item_ans)
        return item_ans

    # ğŸ‰ Festival Offers
    today = str(date.today())
    for fest, details in zepto_data.get("festivals", {}).items():
        if fest in user_input.lower() or details.get("date") == today:
            fest_ans = f"{details.get('wish')} ğŸ‰ {details.get('offer')}"
            append_to_history("assistant", fest_ans)
            return fest_ans

    # ğŸ” Continuations
    if user_input_clean in ("yes", "ok", "okay", "please", "tell me more", "go on", "continue"):
        last_item = context_memory.get("last_item")
        last_cat = context_memory.get("last_category")
        if last_item:
            reply = f"Sure ğŸ˜Š continuing about {last_item.title()} â€” it's available under {last_cat.title() if last_cat else 'Fresh Produce'}. Want me to show how to order or similar items?"
        else:
            reply = "Could you tell me which product you'd like to continue with?"
        append_to_history("assistant", reply)
        return reply

    # ğŸ§  AI fallback last resort
    ai_answer = ask_ai_fallback(user_input)
    if ai_answer:
        return ai_answer

    save_unanswered(user_input)
    reply = "Zepto offers a wide range of essentials â€” could you clarify what product you meant?"
    append_to_history("assistant", reply)
    return reply

# ------------------ MAIN LOOP ------------------
if __name__ == "__main__":
    print("ğŸ›’ Zepto Chatbot (AI + JSON + Context Memory) Ready! Type 'exit' to stop.\n")
    while True:
        user_input = input("You: ").strip()
        if user_input.lower() in ["exit", "quit", "bye", "stop"]:
            print("Chatbot: Bye! ğŸ‘‹ Have a great day!")
            break
        print("Chatbot:", chatbot_response(user_input))
